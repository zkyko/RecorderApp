
# âœ… D365 QA Studio â€” Version 1.5 (New Architecture + Smart Locator Engine)

**Playwright-Powered All-In-One Test Recorder, Locator Cleaner, Runner, and Debugger**  
*(Cursor-ready project README)*

---

## ğŸ“Œ Overview

**D365 QA Studio v1.5** is a desktop application (Electron + Playwright) that lets **manual testers** automate Dynamics 365 F&O testing **without writing or seeing code**.

This version replaces the old POM generator architecture and introduces a simpler, cleaner, and more powerful flow:

- âœ” Record flows with **Playwright Codegen**
- âœ” Auto-clean & upgrade locators using a **D365 Smart Locator Engine**
- âœ” Auto-detect & parameterize input fields
- âœ” Generate **flat Playwright spec files + JSON datasets**
- âœ” Run tests **entirely inside QA Studio**
- âœ” Debug failures with **embedded Trace Viewer & HTML report**
- âœ” Zero manual coding, zero VS Code, zero POM files

---

## ğŸªŸ Single Pane of Glass: Everything From QA Studio

**Core UX principle:**

> Testers should feel like *everything* happens inside **one app** â€” QA Studio.

That means:

- No terminals
- No separate Playwright UIs
- No switching to VS Code or file explorers
- No manually opening trace/report URLs

Even when Playwright launches a browser, Trace Viewer, or HTML report, the tester **starts and returns** to QA Studio:

- QA Studio launches **codegen** and tracks its lifecycle.
- QA Studio starts Playwright test runs and streams logs in its own console.
- QA Studio hosts Trace Viewer / HTML report and embeds them in a `<webview>` tab.
- QA Studio maintains the **Test Library**, **Data Editor**, and **Run dashboard**.

To the tester, QA Studio *is* the test tool. Playwright is just the engine under the hood.

---

## ğŸ”¥ Philosophy of Version 1.5

> **No POMs. No code editors. No fragile locators.  
> Just record â†’ clean â†’ parameterize â†’ run â†’ debug â€” all inside QA Studio.**

This app is an **application layer on top of Playwright**, designed for **manual QA testers**, not engineers.

Automation Engineers still benefit from:

- Clean, stable locators  
- Flat, readable spec files  
- Data-driven execution  
- Easy CI/CD integration  

---

## ğŸ§± Core Features (v1.5)

### 1. Record Tests (via Playwright Codegen)

All recording is initiated from inside QA Studio.

1. Tester clicks **â€œRecord Flowâ€** in QA Studio.
2. QA Studio launches:

   ```bash
   npx playwright codegen <envURL> --storage-state=d365.json
````

3. A browser window opens for D365.
4. Tester performs the business flow.
5. Tester clicks **â€œStop Recordingâ€** back in QA Studio.
6. QA Studio collects and stores the **raw codegen output**.

The tester never touches CLI or config â€” only QA Studio.

---

### 2. Smart Locator Replacement (D365 Locator Engine)

**(NEW in v1.5: POMs removed, locator engine kept)**

Raw Playwright codegen often produces fragile selectors like:

```ts
await page.locator('.dx-grid div:nth-child(5) button').click();
```

But your earlier system already defined a **robust D365 locator strategy**, with priority for attributes like `data-dyn-controlname`, ARIA roles, labels, etc. 

We **reuse that locator strategy** in v1.5, but instead of generating POMs, QA Studio:

* Takes the raw codegen output
* Runs it through the **D365 Smart Locator Engine**
* Replaces each unstable selector with the **best locator**.

#### Locator Priority (v1.5)

1. `data-dyn-controlname="*"`
2. `page.getByRole(...)`
3. `page.getByLabel(...)`
4. `page.getByPlaceholder(...)`
5. `page.getByText(...)` (short + interactive)
6. `data-test-id`
7. Clean CSS fallback (as a last resort)

#### Example Transformation

**Raw codegen:**

```ts
await page.locator('.pane_332 .btn:nth-child(3)').click();
```

**Upgraded by locator engine:**

```ts
await page.locator('[data-dyn-controlname="NewButton"]').click();
// OR
await page.getByRole('button', { name: 'New' });
```

**Raw codegen:**

```ts
await page.locator('#Input_462').fill('US-001');
```

**Upgraded:**

```ts
await page.getByLabel('Customer account').fill(row.customerAccount);
```

The resulting spec file is **stable enough for long-term maintenance** â€” **without POMs**.

---

### 3. Auto-Detect Inputs â†’ Auto-Parameterize

After locator cleanup, QA Studio analyzes the upgraded code and detects:

* `page.fill("value")`
* `page.selectOption("value")`
* Input + `press("Enter")` patterns
  (where the pressed key is part of submitting a value)

QA Studio then shows a parameter mapping UI:

| Field Label      | Value  | Parameterize? | Variable          |
| ---------------- | ------ | ------------- | ----------------- |
| Customer account | US-001 | â˜‘             | `customerAccount` |
| Item number      | D0001  | â˜‘             | `itemNumber`      |
| Warehouse        | 13     | â˜             | â€”                 |

Tester chooses which values should become parameters (checkboxes + variable names).

**Output:**

* A **clean spec file** with `row.customerAccount`, `row.itemNumber`, etc.
* A **JSON data file** that stores one or more dataset rows.

---

### 4. Data Editor (Built-In)

QA Studio renders a **spreadsheet-like data editor** for each testâ€™s JSON file:

* Add new rows (datasets)
* Duplicate an existing row and tweak values
* Toggle datasets on/off
* Edit parameter values without touching JSON directly

Each row â†’ 1 test case instance during execution.

---

### 5. Execute Tests (Inside QA Studio)

Test execution is also initiated **only from QA Studio**:

* Tester selects:

  * A specific test, and
  * Which datasets to run (or â€œRun all active datasetsâ€)

* QA Studio runs:

  ```bash
  npx playwright test <spec>
  ```

* QA Studio streams into a console panel:

  * `stdout`
  * `stderr`
  * timestamps
  * assertion output

No external terminal or CLI tooling is exposed to the tester â€” only the QA Studio console.

---

### 6. Embedded Playwright Debug Tools

Failures are debugged **inside QA Studio**, not via separate browser windows.

From the Test Library or Run Results:

* Tester clicks **â€œOpen Traceâ€** â†’ QA Studio:

  * Starts a `playwright show-trace` server on a local port
  * Embeds it in an Electron `<webview>` inside a **Trace Viewer tab**

* Tester clicks **â€œOpen HTML Reportâ€** â†’ QA Studio:

  * Starts `playwright show-report`
  * Embeds the report inside a **Reports tab**

* Screenshots and videos (if enabled) are linked from within QA Studio.

The tester never has to browse to a folder or paste URLs â€” everything is launched by QA Studio.

---

### 7. Test Library (Single Place to Manage Everything)

QA Studio maintains a **Test Library** view:

| Test Name             | Module | Data Rows | Last Run | Status | Actions                 |
| --------------------- | ------ | --------- | -------- | ------ | ----------------------- |
| Sales Order Creation  | Sales  | 3         | Today    | âŒ Fail | Run Â· Edit Data Â· Trace |
| Customer Invoice Flow | AR     | 2         | 2d ago   | âœ… Pass | Run Â· Edit Data Â· Trace |

From here, testers:

* Run tests
* Update data
* Inspect last results
* Open trace / report

All test lifecycle actions originate from QA Studio.

---

## ğŸ— High-Level Architecture

```text
D365 QA Studio (Electron App)
â”‚
â”œâ”€â”€ Renderer (React UI)
â”‚     â€¢ Home / Test Library
â”‚     â€¢ Record Flow UI
â”‚     â€¢ Locator cleanup preview
â”‚     â€¢ Parameter mapping UI
â”‚     â€¢ Data grid editor
â”‚     â€¢ Run console
â”‚     â€¢ Embedded Trace Viewer & Reports
â”‚
â”œâ”€â”€ Main Process (Node)
â”‚     â€¢ Launches Playwright codegen
â”‚     â€¢ Runs D365 Smart Locator Engine
â”‚     â€¢ Detects parameters
â”‚     â€¢ Writes spec + JSON data files
â”‚     â€¢ Executes Playwright tests
â”‚     â€¢ Starts and proxies trace/report servers
â”‚
â””â”€â”€ Playwright Workspace
      /tests
      /data
      /traces
      /reports
```

---

## ğŸ¬ User Flow (Simplified + Realistic)

### 1. Setup

1. User launches **QA Studio**.
2. Chooses a **storage directory** (workspace).
3. Logs into D365 once (QA Studio captures a `storage_state.json`).
4. QA Studio persists settings for future runs.

### 2. Record

1. In QA Studio, user clicks **â€œRecord Flowâ€**.
2. Codegen browser opens; user performs the D365 flow.
3. User clicks **â€œStop Recordingâ€** in QA Studio.
4. QA Studio pulls the **raw codegen script**.

### 3. Locator Cleanup

QA Studio:

1. Parses the codegen script.
2. For each locator, applies the **D365 Smart Locator Engine**.
3. Rewrites the script with **stable locators**.
4. Shows a **preview** in the UI so advanced users can inspect/approve.

### 4. Parameter Mapping

QA Studio:

1. Scans for hard-coded input values.
2. Shows a mapping table (field label â†’ value â†’ parameter?).
3. Tester checks boxes and sets variable names.
4. QA Studio refactors the script to use `row.<param>` variables.

### 5. Test File Generation

**Spec file:**

```ts
import { test } from '@playwright/test';
import data from './data/salesorder.json';

test.describe('Sales Order - Data Driven', () => {
  for (const row of data) {
    test(`Sales Order - ${row.name}`, async ({ page }) => {
      await page.getByLabel('Customer account').fill(row.customerAccount);
      await page.getByLabel('Item number').fill(row.itemNumber);
      // ...
    });
  }
});
```

**Data file:**

```json
[
  {
    "name": "Default",
    "customerAccount": "US-001",
    "itemNumber": "D0001"
  }
]
```

QA Studio writes them under `/tests` and `/data` for that workspace.

### 6. Run

1. Tester opens **Test Library** in QA Studio.
2. Selects the new test.
3. Chooses which datasets to run.
4. Clicks **Run**.
5. QA Studio executes Playwright and streams logs into the UI.

### 7. Debug

If a dataset fails:

1. Tester clicks **â€œTraceâ€** for that run.
2. QA Studio opens Trace Viewer inside the app.
3. Tester navigates through steps, DOM snapshots, network, console, etc.
4. If needed, they adjust data or re-record the flow â€” always starting from QA Studio.

---

## ğŸ“ Workspace Structure (v1.5)

```text
/qa-studio
â”‚
â”œâ”€â”€ /tests
â”‚     â””â”€â”€ <testName>.spec.ts
â”‚
â”œâ”€â”€ /data
â”‚     â””â”€â”€ <testName>.json
â”‚
â”œâ”€â”€ /traces
â”‚     â””â”€â”€ <run_id>/<test>.zip
â”‚
â””â”€â”€ /reports
      â””â”€â”€ playwright-report/
```

---

## âš™ï¸ Smart Locator Engine (v1.5)

**Locator priority:**

1. `data-dyn-controlname`
2. Role-based (`getByRole`)
3. Label-based (`getByLabel`)
4. Placeholder (`getByPlaceholder`)
5. Text (`getByText`)
6. `data-test-id`
7. Final CSS fallback

**Process:**

1. Parse codegen file.
2. For each locator:

   * Optionally re-identify target in DOM
   * Extract all candidate locators
   * Score them by stability & readability
   * Pick the best one by priority.
3. Rewrite the test file with the chosen locator.

**Guarantees:**

* Stable across UI shifts.
* Reproducible and readable.
* Works without POMs.
* Tuned for D365 F&Oâ€™s iframe-heavy, dynamic DOM.

---

## ğŸ§ª Test Execution Engine

QA Studio runs something like:

```bash
npx playwright test --grep "<testName>"
```

and pipes to the UI:

* Logs
* Errors
* Attachments
* Links to traces and reports

All displayed and accessed **inside QA Studio**.

---

## ğŸªŸ UI Structure (Cursor Build Targets)

### React Screens

* `HomeScreen.tsx` â€” overall navigation, recent runs.
* `TestLibraryScreen.tsx` â€” list of tests, datasets, run actions.
* `RecordScreen.tsx` â€” start/stop recording, status.
* `LocatorCleanupScreen.tsx` â€” show cleaned code snippet (read-only or advanced).
* `ParamMappingScreen.tsx` â€” parameter table UI.
* `DataEditorScreen.tsx` â€” dataset grid editor.
* `RunScreen.tsx` â€” execution console and summary.
* `TraceViewerScreen.tsx` â€” embedded trace viewer.
* `ReportViewerScreen.tsx` â€” embedded HTML report.

### Main Process Modules

* `codegen-service.ts` â†’ launches & manages `playwright codegen`.
* `locator-engine.ts` â†’ applies D365 locator rules to raw code.
* `parameterizer.ts` â†’ detects + injects parameters into the spec.
* `spec-writer.ts` â†’ writes cleaned `.spec.ts` files.
* `data-writer.ts` â†’ creates & updates `.json` dataset files.
* `test-runner.ts` â†’ runs Playwright tests, streams logs to renderer.
* `trace-server.ts` â†’ starts Trace Viewer / HTML report and passes URLs to renderer.
* `settings-store.ts` â†’ handles workspace, env URLs, storage_state path, etc.

---

## ğŸ Why Version 1.5 Is Stronger Than Both v1.0 and Pure Codegen

**Removed (good riddance):**

* âŒ POM generator
* âŒ Page classification
* âŒ Multi-file POM structure
* âŒ Recorder â†’ POM â†’ Spec complexity

**Kept (very important):**

* âœ… Advanced D365 locator engine (from the original standalone design) 

**Added:**

* âœ” Clean, flat Playwright tests
* âœ” Auto-dataset / data-driven runs
* âœ” Fully embedded Trace & HTML report
* âœ” Single QA Studio app controlling everything
* âœ” Zero-code test authoring workflow
* âœ” Simpler architecture that still scales

---

**This README is ready to drop into your repo for Cursor.**
QA Studio is clearly the **one place** where everything â€” record, clean, parameterize, run, debug â€” happens.

```
```
