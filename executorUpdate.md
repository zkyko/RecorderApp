D365 Test Executor & BrowserStack Integration Guide1. ObjectiveAdd a "Test Runner" feature to the Electron GUI that allows users to:Select a generated Test Spec.Load and Edit the associated JSON Data file in a UI grid/form.Execute the test locally OR on BrowserStack.View live console logs and pass/fail status.2. Architecture ChangesA. The "Data Editor" (UI Layer)We are leveraging the Method #2 architecture (JSON-driven specs).Feature: When a user selects a spec (e.g., create_so.spec.ts), the app must identify the imported JSON file (e.g., create_so_data.json).Interaction: Display the JSON content in a tailored React Table/Editor.Action: When the user changes a value (e.g., changes Quantity from 5 to 10) and clicks "Run", the app MUST write these changes to disk before triggering the test.B. The "Execution Engine" (Electron Main Process)The Electron app cannot run Playwright tests inside the main thread. It must spawn a Child Process.New IPC Handlers required in electron/main.ts:run-test-local: Spawns npx playwright test <spec_file>.run-test-browserstack: Spawns the test with specific Environment Variables for BrowserStack.save-test-data:Validates the JSON structure.Creates a backup of the existing file (filename.json.bak).Overwrites the file with new UI inputs.C. BrowserStack Integration LogicTo run on BrowserStack without changing the generated code, we will inject a Custom Project Config or use Environment Variables that the Playwright Config listens to.The Command Line Strategy:# How Electron will spawn the process
cross-env BROWSERSTACK_USERNAME=xxx BROWSERSTACK_ACCESS_KEY=yyy npx playwright test tests/my-spec.spec.ts --config=playwright.browserstack.config.ts
3. Implementation Details for CursorA. New Config File: playwright.browserstack.config.tsCreate a dedicated config for cloud execution. It must:Read BROWSERSTACK_USERNAME and BROWSERSTACK_ACCESS_KEY from process.env.Construct the CDP (Chrome DevTools Protocol) URL:wss://cdp.browserstack.com/playwright?caps=...Use the connectOptions in the project config.B. The React "Runner" ComponentCreate src/ui/components/TestRunner.tsx:Layout: Split pane. Left side = Spec List. Right side = Data Editor + Console.Data Editor: Use a library like react-json-view or a simple HTML form mapping the JSON keys.BrowserStack Settings: A modal to save BS Username/Key (persist in electron-store).C. Child Process LoggingThe IPC handler must stream stdout and stderr from the spawned Playwright process back to the React UI in real-time so the user sees "Running...", "Step 1...", "Passed".4. Security NoteBrowserStack Credentials must be stored in electron-store (local machine), NEVER hardcoded in the source or generated files.5. D365 Specifics for ExecutionEnsure the runner sets the viewport size to 1920x1080 explicitly, as D365 collapses columns on smaller screens (mobile view), which breaks locators.6. Data Integrity & Verification Strategy (New)To satisfy the requirement of "Verifying data later", the Execution Engine must perform Run-Time Snapshotting:The Backup Rule: Before save-test-data overwrites data.json, it must copy the old version to data.json.bak.The Audit Attachment:When the test runs, the framework should attach the actual JSON data used to the Playwright Report.This allows you to open a historical test report and see exactly what data was used for that specific run, even if the file on disk has changed since then.Implementation:In the spec-generator.ts, add a test.info().attach(...) call inside the loop.This ensures the JSON object is embedded permanently in the test results ZIP/HTML.// Example of what spec-generator should produce to enable verification
test(`Case ${data.id}`, async ({ page }, testInfo) => {
    // ATTACH DATA FOR AUDIT
    await testInfo.attach('test-data', {
        body: JSON.stringify(data, null, 2),
        contentType: 'application/json'
    });
    
    // ... rest of test
});
